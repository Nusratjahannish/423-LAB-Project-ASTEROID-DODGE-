# -*- coding: utf-8 -*-
"""game3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J_QlHvtk4n5ubcpxZHo8dPlLffGVlD4v
"""

# -*- coding: utf-8 -*-
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
import sys, random, math, time

# ---------------- Window (hardcoded viewport) ----------------
winW, winH = 800, 600

# ---------------- Camera params ----------------
FOVY_DEG   = 40.0
NEAR_PLANE = 0.1
FAR_PLANE  = 50.0

# Assignment-style camera
UP = (0.0, 1.0, 0.0)
cam_follow   = False        # RMB toggles follow/orbit
cam_yaw_deg  = 0.0          # LEFT/RIGHT rotate around play area
cam_radius   = 2.2          # orbit distance
cam_height   = 1.6          # UP/DOWN adjust height
EYE_CUR      = [0.0, -2.0, 1.6]
CTR_CUR      = [0.0,  0.0, 0.0]

# ---------------- Time ----------------
start_time = None
prev_time  = None
t_global   = 0.0
def now_t(): return time.time() - start_time

# ---------------- Colors ----------------
SKY_ROYAL_DARK = (0.08, 0.14, 0.36)
STAR_TINT      = (0.90, 0.95, 1.00)

# Boundary star colors (fill & outline)
BND_STAR_FILL    = (1.00, 0.95, 0.10)  # yellow
BND_STAR_OUTLINE = (0.00, 0.00, 0.00)  # black

SHIP_BODY      = (0.95, 0.40, 0.12)
SHIP_BAND      = (1.00, 0.90, 0.15)
SHIP_DOME      = (0.60, 0.95, 1.00)
LEG_DARK       = (0.18, 0.22, 0.30)
LEG_LIGHT      = (0.55, 0.65, 0.80)

ASTEROID_LIGHT = (0.72, 0.66, 0.58)
ASTEROID_DARK  = (0.55, 0.48, 0.42)

GIANT_LIGHT    = (0.80, 0.62, 0.45)
GIANT_DARK     = (0.50, 0.38, 0.26)

BONUS_LIGHT    = (0.20, 0.95, 0.65)
BONUS_DARK     = (0.10, 0.60, 0.40)

BULLET_COLOR   = (1.00, 0.98, 0.25)
BLAST_COLORS   = [(1.0,0.9,0.2),(1.0,0.6,0.1),(1.0,0.85,0.35)]

OUTLINE_BLACK  = (0.0, 0.0, 0.0)
NEON_GREEN     = (0.10, 1.00, 0.35)

RING_DARK      = (0.04, 0.10, 0.25)
RING_LIGHT     = (0.10, 0.25, 0.50)

# Lipliner scales
OUTLINE_BLACK_SCALE = 1.08
NEON_OUTLINE_SCALE  = 1.035

# ---------------- Game state ----------------
STATE_MENU = 0
STATE_INSTR = 1
STATE_PLAY = 2
game_state = STATE_MENU
paused = False

# Difficulty (0=Easy,1=Medium,2=Hard) â€” default Medium
difficulty_idx = 1

# Base asteroid tuning (scaled per difficulty)
BASE_SPAWN_EVERY = 2
BASE_SPEED_MIN   = 0.18
BASE_SPEED_MAX   = 0.32
AST_SIZE_MIN     = 0.040
AST_SIZE_MAX     = 0.080

# Active (difficulty-applied) tuning
spawn_every = BASE_SPAWN_EVERY
speed_min   = BASE_SPEED_MIN
speed_max   = BASE_SPEED_MAX
ast_size_scale = 1.0

# Hard-mode extras
HARD_GIANT_PROB  = 0.25
HARD_GIANT_SCALE = 3.0
HARD_SPLIT_PROB  = 0.60
SPLIT_MIN_R      = 0.10

def apply_difficulty():
    global spawn_every, speed_min, speed_max, ast_size_scale
    if difficulty_idx == 0:            # EASY
        spawn_every   = BASE_SPAWN_EVERY * 1.6
        speed_min     = BASE_SPEED_MIN * 0.75
        speed_max     = BASE_SPEED_MAX * 0.75
        ast_size_scale= 1.00
    elif difficulty_idx == 1:          # MEDIUM
        spawn_every   = BASE_SPAWN_EVERY * 0.95
        speed_min     = BASE_SPEED_MIN * 1.25
        speed_max     = BASE_SPEED_MAX * 1.30
        ast_size_scale= 1.80
    else:                               # HARD
        spawn_every   = BASE_SPAWN_EVERY * 0.55
        speed_min     = BASE_SPEED_MIN * 1.70
        speed_max     = BASE_SPEED_MAX * 1.75
        ast_size_scale= 2.40

# ---------------- Lives / Score ----------------
MAX_LIVES = 10
lives = MAX_LIVES
score = 0
game_over = False

# ---------------- Cheat Mode ----------------
cheat_active = False
gun_angle_deg = 0.0
GUN_SPIN_SPEED_DEG = 220.0
AUTOFIRE_COOLDOWN = 0.12
autofire_timer = 0.0
AIM_COS_THRESH = math.cos(math.radians(12.0))

# ---------------- Starfield ----------------
STARS_DIST = 40.0
stars = []
def init_stars(n=900):
    global stars
    stars = []
    for _ in range(n):
        z = -random.uniform(0.15, 1.0)
        r_xy = math.sqrt(max(1.0 - z*z, 0.0))
        phi = random.uniform(0.0, 2.0*math.pi)
        x = r_xy * math.cos(phi)
        y = r_xy * math.sin(phi)
        phase = random.uniform(0.0, 2.0*math.pi)
        stars.append([x, y, z, phase])

def draw_sky_fullscreen():
    aspect = max(1e-6, winW/float(winH))
    half_h = math.tan(math.radians(FOVY_DEG * 0.5)) * FAR_PLANE
    half_w = aspect * half_h
    z = -FAR_PLANE * 0.99
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()
    glBegin(GL_TRIANGLES)
    glColor3f(SKY_ROYAL_DARK[0]*0.9, SKY_ROYAL_DARK[1]*0.9, SKY_ROYAL_DARK[2]*0.9)
    glVertex3f(-half_w, -half_h, z)
    glColor3f(SKY_ROYAL_DARK[0], SKY_ROYAL_DARK[1], SKY_ROYAL_DARK[2])
    glVertex3f( half_w, -half_h, z)
    glColor3f(SKY_ROYAL_DARK[0]*0.75, SKY_ROYAL_DARK[1]*0.75, SKY_ROYAL_DARK[2]*0.75)
    glVertex3f( half_w,  half_h, z)
    glColor3f(SKY_ROYAL_DARK[0]*0.9, SKY_ROYAL_DARK[1]*0.9, SKY_ROYAL_DARK[2]*0.9)
    glVertex3f(-half_w, -half_h, z)
    glColor3f(SKY_ROYAL_DARK[0]*0.75, SKY_ROYAL_DARK[1]*0.75, SKY_ROYAL_DARK[2]*0.75)
    glVertex3f( half_w,  half_h, z)
    glColor3f(SKY_ROYAL_DARK[0]*0.6, SKY_ROYAL_DARK[1]*0.6, SKY_ROYAL_DARK[2]*0.6)
    glVertex3f(-half_w,  half_h, z)
    glEnd()
    glPopMatrix()

def draw_stars(t):
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()
    glBegin(GL_POINTS)
    for x, y, z, ph in stars:
        tw = 0.45 + 0.55*(0.5 + 0.5*math.sin(2.1*t + ph))
        glColor3f(STAR_TINT[0]*tw, STAR_TINT[1]*tw, STAR_TINT[2]*tw)
        glVertex3f(x*STARS_DIST, y*STARS_DIST, z*STARS_DIST)
    glEnd()
    glPopMatrix()

# ---------------- Pulsing ----------------
def pulse_scale(t, phase, amp, freq):
    return 1.0 + amp * math.sin(2.0 * math.pi * freq * t + phase)

SHIP_PULSE_AMP, SHIP_PULSE_FREQ = 0.06, 1.10
AST_PULSE_AMP,  AST_PULSE_FREQ  = 0.10, 0.90
BON_PULSE_AMP,  BON_PULSE_FREQ  = 0.12, 1.20
BH_PULSE_AMP,   BH_PULSE_FREQ   = 0.08, 0.85
BUL_PULSE_AMP,  BUL_PULSE_FREQ  = 0.15, 1.40
CRY_PULSE_AMP,  CRY_PULSE_FREQ  = 0.12, 1.00
ORB_PULSE_AMP,  ORB_PULSE_FREQ  = 0.12, 1.10

# ---------------- 3D primitives ----------------
def draw_cuboid_solid(dx, dy, dz, col):
    glColor3f(*col)
    x=dx*0.5; y=dy*0.5; z=dz*0.5
    glBegin(GL_QUADS)
    glVertex3f( x,-y,-z); glVertex3f( x, y,-z); glVertex3f( x, y, z); glVertex3f( x,-y, z)
    glVertex3f(-x,-y,-z); glVertex3f(-x,-y, z); glVertex3f(-x, y, z); glVertex3f(-x, y,-z)
    glVertex3f(-x, y,-z); glVertex3f(-x, y, z); glVertex3f( x, y, z); glVertex3f( x, y,-z)
    glVertex3f(-x,-y,-z); glVertex3f( x,-y,-z); glVertex3f( x,-y, z); glVertex3f(-x,-y, z)
    glVertex3f(-x,-y, z); glVertex3f( x,-y, z); glVertex3f( x, y, z); glVertex3f(-x, y, z)
    glVertex3f(-x,-y,-z); glVertex3f(-x, y,-z); glVertex3f( x, y,-z); glVertex3f( x,-y,-z)
    glEnd()

def draw_disc_y_solid(yc, r, seg, col):
    glColor3f(*col)
    glBegin(GL_TRIANGLES)
    for i in range(seg):
        a0 = 2*math.pi*(i/float(seg)); a1 = 2*math.pi*((i+1)/float(seg))
        x0, z0 = r*math.cos(a0), r*math.sin(a0)
        x1, z1 = r*math.cos(a1), r*math.sin(a1)
        glVertex3f(0, yc, 0); glVertex3f(x0, yc, z0); glVertex3f(x1, yc, z1)
    glEnd()

def draw_ring_y_solid(yc, r0, r1, seg, col0, col1):
    glBegin(GL_TRIANGLES)
    for i in range(seg):
        a0=2*math.pi*(i/float(seg)); a1=2*math.pi*((i+1)/float(seg))
        c0x,c0z = r0*math.cos(a0), r0*math.sin(a0)
        c1x,c1z = r1*math.cos(a0), r1*math.sin(a0)
        c2x,c2z = r1*math.cos(a1), r1*math.sin(a1)
        c3x,c3z = r0*math.cos(a1), r0*math.sin(a1)
        glColor3f(*col0); glVertex3f(c0x, yc, c0z); glVertex3f(c1x, yc, c1z); glVertex3f(c2x, yc, c2z)
        glColor3f(*col1); glVertex3f(c0x, yc, c0z); glVertex3f(c2x, yc, c2z); glVertex3f(c3x, yc, c3z)
    glEnd()

def draw_cylinder_solid(h, r, seg, col):
    half=h*0.5
    glColor3f(*col)
    glBegin(GL_TRIANGLES)
    for i in range(seg):
        a0=2*math.pi*(i/float(seg)); a1=2*math.pi*((i+1)/float(seg))
        x0=r*math.cos(a0); z0=r*math.sin(a0)
        x1=r*math.cos(a1); z1=r*math.sin(a1)
        glVertex3f(x0,-half,z0); glVertex3f(x1,-half,z1); glVertex3f(x1,half,z1)
        glVertex3f(x0,-half,z0); glVertex3f(x1,half,z1);  glVertex3f(x0,half,z0)
    glEnd()
    draw_disc_y_solid(-half, r, seg, col)
    draw_disc_y_solid( half, r, seg, col)

def draw_sphere_solid(r, segW, segH, col_light, col_dark):
    for i in range(segH):
        th0 = math.pi * (i    /float(segH)) - math.pi/2.0
        th1 = math.pi * ((i+1)/float(segH)) - math.pi/2.0
        y0 = r*math.sin(th0); y1 = r*math.sin(th1)
        rr0= r*math.cos(th0); rr1= r*math.cos(th1)
        row_col = col_light if (i % 2 == 0) else col_dark
        glColor3f(*row_col)
        glBegin(GL_TRIANGLES)
        for j in range(segW):
            ph0=2*math.pi*(j    /float(segW)); ph1=2*math.pi*((j+1)/float(segW))
            x00=rr0*math.cos(ph0); z00=rr0*math.sin(ph0)
            x01=rr0*math.cos(ph1); z01=rr0*math.sin(ph1)
            x10=rr1*math.cos(ph0); z10=rr1*math.sin(ph0)
            x11=rr1*math.cos(ph1); z11=rr1*math.sin(ph1)
            glVertex3f(x00,y0,z00); glVertex3f(x01,y0,z01); glVertex3f(x11,y1,z11)
            glVertex3f(x00,y0,z00); glVertex3f(x11,y1,z11); glVertex3f(x10,y1,z10)
        glEnd()

# ---------------- Camera math ----------------
def _normalize(v):
    L = math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]) or 1.0
    return (v[0]/L, v[1]/L, v[2]/L)
def _cross(a,b):
    return (a[1]*b[2] - a[2]*b[1],
            a[2]*b[0] - a[0]*b[2],
            a[0]*b[1] - a[1]*b[0])

cam = {}
def _set_cam_math(ex,ey,ez,cx,cy,cz):
    f = _normalize((cx-ex, cy-ey, cz-ez))
    s = _normalize(_cross(f, UP))
    u = _cross(s, f)
    aspect = winW/float(winH)
    tHY = math.tan(math.radians(FOVY_DEG/2.0))
    tHX = aspect * tHY
    cam.update({"E": (ex,ey,ez), "f": f, "s": s, "u": u, "tHY": tHY, "tHX": tHX})

def update_camera_from_state():
    global EYE_CUR, CTR_CUR
    if cam_follow:
        sx, sy, sz = ship["p"]
        ex, ey, ez = sx, sy - 0.60, sz + 0.35     # behind & slightly above ship
        cx, cy, cz = sx, sy, sz + 0.05
    else:
        a  = math.radians(cam_yaw_deg)
        ex = cam_radius * math.sin(a)
        ey = -cam_radius * math.cos(a)
        ez = cam_height
        cx, cy, cz = 0.0, 0.0, 0.0
    EYE_CUR = [ex,ey,ez]; CTR_CUR = [cx,cy,cz]
    _set_cam_math(ex,ey,ez,cx,cy,cz)

# --- World<->Screen helpers (for HUD) ---
def world_to_screen(wx, wy, wz=0.0):
    ex,ey,ez = cam["E"]; s=cam["s"]; u=cam["u"]; f=cam["f"]; tHX=cam["tHX"]; tHY=cam["tHY"]
    dx,dy,dz = wx-ex, wy-ey, wz-ez
    xs = dx*s[0] + dy*s[1] + dz*s[2]
    yu = dx*u[0] + dy*u[1] + dz*u[2]
    ze = dx*f[0] + dy*f[1] + dz*f[2]
    if ze <= 1e-6: return None
    xn = xs / (ze*tHX)
    yn = yu / (ze*tHY)
    sx = int((xn*0.5 + 0.5) * winW)
    sy = int((yn*0.5 + 0.5) * winH)
    return (sx, sy)

def ndc_ray_dir(xn, yn):
    f = cam["f"]; s = cam["s"]; u = cam["u"]; tHX = cam["tHX"]; tHY = cam["tHY"]
    dx = f[0] + xn*tHX*s[0] + yn*tHY*u[0]
    dy = f[1] + xn*tHX*s[1] + yn*tHY*u[1]
    dz = f[2] + xn*tHX*s[2] + yn*tHY*u[2]
    return _normalize((dx,dy,dz))

def intersect_plane_z_from_ndc(zplane, xn, yn):
    ex,ey,ez = cam["E"]
    rx,ry,rz = ndc_ray_dir(xn, yn)
    if abs(rz) < 1e-6: return None
    t = (zplane - ez) / rz
    return (ex + rx*t, ey + ry*t, zplane)

def compute_frustum_corners_on_plane(zplane=0.0):
    TL = intersect_plane_z_from_ndc(zplane, -1.0, +1.0)
    TR = intersect_plane_z_from_ndc(zplane, +1.0, +1.0)
    BR = intersect_plane_z_from_ndc(zplane, +1.0, -1.0)
    BL = intersect_plane_z_from_ndc(zplane, -1.0, -1.0)
    return TL, TR, BR, BL

# ---------------- Play volume (3D box) ----------------
X_MAX  = 1.40
Y_MIN, Y_MAX = -1.0, 0.90
Z_MIN, Z_MAX = -0.60, 0.35

# ---------------- Spaceship (pulsing & clamp) ----------------
ship = {"p":[0.0, -0.25, 0.0], "scale":0.85, "ph": random.uniform(0, 2*math.pi)}
def ship_pulse_scale():
    return pulse_scale(t_global, ship["ph"], SHIP_PULSE_AMP, SHIP_PULSE_FREQ)
BASE_STEP_UNIT   = 0.01
SPEED_UNIT_MIN   = 0
speed_units      = 6
slow_timer   = 0.0
SLOW_FACTOR  = 0.40
alert_timer  = 0.0

def current_step():
    base = speed_units * BASE_STEP_UNIT
    if slow_timer > 0.0: return base * SLOW_FACTOR
    return base

def ship_half_extents_world():
    s = 0.6 * ship["scale"] * ship_pulse_scale()
    hx = 0.70 * s; hy = 0.45 * s; hz = 0.36 * s
    return hx, hy, hz

def draw_ship_silhouette(s, scale_mult, color):
    glPushMatrix()
    glScalef(scale_mult, scale_mult, scale_mult)
    glPushMatrix()
    glScalef(0.75*s, 0.45*s, 0.28*s)
    draw_sphere_solid(0.9, 18, 14, color, color)
    glPopMatrix()
    draw_cylinder_solid(0.10*s, 0.36*s, 28, color)
    glPushMatrix()
    glTranslatef(0, 0.10*s, 0.10*s)
    glScalef(0.35*s, 0.28*s, 0.22*s)
    draw_sphere_solid(1.0, 14, 12, color, color)
    glPopMatrix()
    for x in [-0.22*s, 0.0, 0.22*s]:
        glPushMatrix()
        glTranslatef(x, -0.12*s, -0.02*s)
        draw_cylinder_solid(0.14*s, 0.02*s, 12, color)
        glTranslatef(0, -0.02*s, -0.03*s)
        draw_cuboid_solid(0.06*s, 0.02*s, 0.06*s, color)
        glPopMatrix()
    glPushMatrix()
    glTranslatef(0.0, 0.20*s, 0.10*s)
    glRotatef(gun_angle_deg, 0, 0, 1)
    draw_cylinder_solid(0.18*s, 0.02*s, 16, color)
    glPopMatrix()
    glPopMatrix()

def draw_ship_colored(s):
    glPushMatrix()
    glScalef(0.75*s, 0.45*s, 0.28*s)
    draw_sphere_solid(0.9, 20, 16, SHIP_BODY, (SHIP_BODY[0]*0.85, SHIP_BODY[1]*0.85, SHIP_BODY[2]*0.85))
    glPopMatrix()
    draw_cylinder_solid(0.10*s, 0.36*s, 28, SHIP_BAND)
    glPushMatrix()
    glTranslatef(0, 0.10*s, 0.10*s)
    glScalef(0.35*s, 0.28*s, 0.22*s)
    draw_sphere_solid(1.0, 16, 12, SHIP_DOME, (SHIP_DOME[0]*0.85, SHIP_DOME[1]*0.85, SHIP_DOME[2]*0.85))
    glPopMatrix()
    for x in [-0.22*s, 0.0, 0.22*s]:
        glPushMatrix()
        glTranslatef(x, -0.12*s, -0.02*s)
        draw_cylinder_solid(0.14*s, 0.02*s, 12, LEG_DARK)
        glTranslatef(0, -0.02*s, -0.03*s)
        draw_cuboid_solid(0.06*s, 0.02*s, 0.06*s, LEG_LIGHT)
        glPopMatrix()
    glPushMatrix()
    glTranslatef(0.0, 0.20*s, 0.10*s)
    glRotatef(gun_angle_deg, 0, 0, 1)
    draw_cylinder_solid(0.18*s, 0.02*s, 16, (0.15,0.15,0.15))
    glPopMatrix()

def draw_spaceship():
    s = 0.6 * ship["scale"] * ship_pulse_scale()
    cx, cy, cz = ship["p"]
    glPushMatrix()
    glTranslatef(cx, cy, cz)
    draw_ship_silhouette(s, OUTLINE_BLACK_SCALE, OUTLINE_BLACK)
    if cheat_active:
        draw_ship_silhouette(s, NEON_OUTLINE_SCALE, NEON_GREEN)
    draw_ship_colored(s)
    glPopMatrix()

def clamp_ship_inside():
    hx, hy, hz = ship_half_extents_world()
    x, y, z = ship["p"]
    x = max(-X_MAX + hx, min(X_MAX - hx, x))
    y = max(Y_MIN + hy, min(Y_MAX - hy, y))
    z = max(Z_MIN + hz, min(Z_MAX - hz, z))
    ship["p"] = [x, y, z]

# ---------------- Asteroids (pulsing, now 3D) ----------------
asteroids = []
asteroid_timer = 0.0
def spawn_asteroid():
    base_r = random.uniform(AST_SIZE_MIN, AST_SIZE_MAX)
    r = base_r * ast_size_scale
    a_type = "normal"
    split_flag = False
    if difficulty_idx == 2:
        if random.random() < HARD_GIANT_PROB:
            a_type = "giant"; r *= HARD_GIANT_SCALE; split_flag = True
        else:
            split_flag = (random.random() < HARD_SPLIT_PROB)
    y = Y_MAX + r + 0.05
    x = random.uniform(-X_MAX + r, X_MAX - r)
    z = random.uniform(Z_MIN + r, Z_MAX - r)
    vy = -random.uniform(speed_min, speed_max)
    vz = random.uniform(-0.08, 0.08)
    asteroids.append({"p":[x,y,z], "r":r, "vy":vy, "vz":vz, "type":a_type, "split":split_flag,
                      "ph": random.uniform(0, 2*math.pi)})

def update_asteroids(dt):
    global asteroid_timer
    asteroid_timer += dt
    if asteroid_timer >= spawn_every:
        spawn_asteroid(); asteroid_timer = 0.0
    for a in asteroids:
        a["p"][1] += a["vy"] * dt
        a["p"][2] += a["vz"] * dt
    asteroids[:] = [a for a in asteroids if a["p"][1] > Y_MIN - a["r"] - 0.20]

def asteroid_scale(a):
    return pulse_scale(t_global, a["ph"], AST_PULSE_AMP, AST_PULSE_FREQ)

def draw_asteroid(a):
    x,y,z=a["p"]; r=a["r"]; sc = asteroid_scale(a)
    glPushMatrix(); glTranslatef(x,y,z); glScalef(sc, sc, sc)
    draw_sphere_solid(r*1.06, 16, 12, OUTLINE_BLACK, OUTLINE_BLACK)
    if a.get("type","normal") == "giant":
        draw_sphere_solid(r, 22, 16, GIANT_LIGHT, GIANT_DARK)
        glPushMatrix(); glRotatef(90, 1,0,0)
        draw_cylinder_solid(r*0.18, r*0.72, 28, (0.35,0.30,0.28))
        glPopMatrix()
    else:
        draw_sphere_solid(r, 20, 14, ASTEROID_LIGHT, ASTEROID_DARK)
    glPopMatrix()

# ---------------- BONUS (+3) 3D ----------------
bonuses = []
bonus_timer = 0.0
BONUS_SPAWN_EVERY_MIN = 6.0
BONUS_SPAWN_EVERY_MAX = 11.0
next_bonus_spawn = 7.5
def reset_next_bonus():
    global next_bonus_spawn
    next_bonus_spawn = random.uniform(BONUS_SPAWN_EVERY_MIN, BONUS_SPAWN_EVERY_MAX)
def spawn_bonus():
    r = random.uniform(0.045, 0.065)
    y = Y_MAX + r + 0.06
    x = random.uniform(-X_MAX + r, X_MAX - r)
    z = random.uniform(Z_MIN + r, Z_MAX - r)
    vy = -random.uniform(0.15, 0.24)
    rot = random.uniform(0.0, 360.0)
    bonuses.append({"p":[x,y,z], "r":r, "vy":vy, "rot":rot, "ph": random.uniform(0, 2*math.pi)})
def update_bonuses(dt):
    global bonus_timer
    bonus_timer += dt
    if bonus_timer >= next_bonus_spawn:
        spawn_bonus(); bonus_timer = 0.0; reset_next_bonus()
    for b in bonuses:
        b["p"][1] += b["vy"] * dt
        b["rot"] = (b["rot"] + 60.0*dt) % 360.0
    bonuses[:] = [b for b in bonuses if b["p"][1] > Y_MIN - b["r"] - 0.20]
def bonus_scale(b): return pulse_scale(t_global, b["ph"], BON_PULSE_AMP, BON_PULSE_FREQ)
def draw_bonus(b):
    x,y,z = b["p"]; r=b["r"]; sc = bonus_scale(b)
    glPushMatrix(); glTranslatef(x,y,z); glRotatef(b["rot"], 0,0,1); glScalef(sc, sc, sc)
    draw_sphere_solid(r*1.06, 14, 10, OUTLINE_BLACK, OUTLINE_BLACK)
    draw_sphere_solid(r, 16, 12, BONUS_LIGHT, BONUS_DARK)
    draw_cylinder_solid(0.03, r*0.65, 14, (0.85,0.95,0.95))
    glPopMatrix()
def collided_ship_bonus(b):
    sx, sy, sz = ship["p"]; bx, by, bz = b["p"]
    R = ship_collision_radius() + b["r"]*bonus_scale(b)*0.8
    dx = bx - sx; dy = by - sy; dz = bz - sz
    return (dx*dx + dy*dy + dz*dz) <= (R*R)
bonus_texts = []
def spawn_bonus_text(wx, wy, wz): bonus_texts.append({"wx": wx, "wy": wy, "wz": wz, "ttl": 1.2, "rise": 0.18})
def update_bonus_texts(dt):
    for t in bonus_texts: t["wy"] += t["rise"] * dt; t["ttl"] -= dt
    i=0
    while i < len(bonus_texts):
        if bonus_texts[i]["ttl"] <= 0.0: bonus_texts.pop(i)
        else: i += 1
def draw_bonus_texts_overlay():
    for t in bonus_texts:
        scr = world_to_screen(t["wx"], t["wy"], t["wz"])
        if scr is None: continue
        sx, sy = scr; draw_text(sx - 50, sy, "BONUS +3")

# ---------------- Blackholes (chasing, 3D) ----------------
blackholes = []
bh_next_spawn = 0.0
BH_RESPAWN_AFTER = 6.0
BH_SPEED_MED  = 0.28
BH_SPEED_HARD = 0.42
def blackhole_target_count():
    if difficulty_idx == 1: return 1
    if difficulty_idx == 2: return 2
    return 0
def spawn_one_blackhole():
    r = 0.13 if difficulty_idx == 1 else 0.15
    y = random.uniform(Y_MIN + 0.35, Y_MAX - 0.35)
    x = random.uniform(-X_MAX + 0.25, X_MAX - 0.25)
    z = random.uniform(Z_MIN + 0.20, Z_MAX - 0.20)
    blackholes.append({"p":[x,y,z], "r":r, "ph": random.uniform(0, 2*math.pi)})
def despawn_blackhole_at(idx): blackholes.pop(idx)
def bh_scale(bh): return pulse_scale(t_global, bh["ph"], BH_PULSE_AMP, BH_PULSE_FREQ)
def draw_blackholes():
    for bh in blackholes:
        x,y,z = bh["p"]; r=bh["r"]; sc = bh_scale(bh)
        glPushMatrix(); glTranslatef(x,y,z)
        draw_disc_y_solid(0.0, r*0.95*sc, 28, OUTLINE_BLACK)
        draw_ring_y_solid(0.0, r*1.05*sc, r*1.85*sc, 40, RING_LIGHT, RING_DARK)
        glPopMatrix()
def collided_ship_blackhole(bh):
    sx, sy, sz = ship["p"]; bx, by, bz = bh["p"]; r = bh["r"]*bh_scale(bh)
    dx = bx - sx; dy = by - sy; dz = bz - sz
    R = ship_collision_radius() + r*0.85
    return (dx*dx + dy*dy + dz*dz) <= (R*R)
def update_blackholes_motion(dt):
    if not blackholes: return
    speed = BH_SPEED_MED if difficulty_idx == 1 else BH_SPEED_HARD
    sx, sy, sz = ship["p"]
    for bh in blackholes:
        bx, by, bz = bh["p"]; dx = sx - bx; dy = sy - by; dz = sz - bz
        L = math.sqrt(dx*dx + dy*dy + dz*dz)
        if L > 1e-6:
            ux = dx / L; uy = dy / L; uz = dz / L
            bh["p"][0] = bx + ux * speed * dt
            bh["p"][1] = by + uy * speed * dt
            bh["p"][2] = bz + uz * speed * dt

# ---------------- Collision / blasts ----------------
def ship_collision_radius():
    hx, hy, hz = ship_half_extents_world()
    return math.sqrt(hx*hx + hy*hy + hz*hz)
def collided_ship_asteroid(a):
    sx, sy, sz = ship["p"]; ax, ay, az = a["p"]
    R = ship_collision_radius() + a["r"]*asteroid_scale(a)
    dx = ax - sx; dy = ay - sy; dz = az - sz
    return (dx*dx + dy*dy + dz*dz) <= (R*R)
blasts = []
def spawn_blast(x, y, z, count=90):
    for _ in range(count):
        ang = random.uniform(0.0, 2.0*math.pi)
        elev= random.uniform(-math.pi/2, math.pi/2)
        spd = random.uniform(0.6, 1.4)
        vx  = math.cos(elev)*math.cos(ang) * spd
        vy  = math.sin(elev)             * spd
        vz  = math.cos(elev)*math.sin(ang) * spd
        ttl = random.uniform(0.35, 0.8); ci  = random.randint(0, len(BLAST_COLORS)-1)
        blasts.append([x, y, z, vx, vy, vz, ttl, ci])
def update_blasts(dt):
    drag = 0.96
    for p in blasts:
        p[0] += p[3] * dt; p[1] += p[4] * dt; p[2] += p[5] * dt
        p[3] *= drag; p[4] *= drag; p[5] *= drag; p[6] -= dt
    i = 0
    while i < len(blasts):
        if blasts[i][6] <= 0.0: blasts.pop(i)
        else: i += 1
def draw_blasts():
    if not blasts: return
    glBegin(GL_POINTS)
    for (x,y,z,_,_,_,ttl,ci) in blasts:
        c = BLAST_COLORS[ci]; k = max(0.0, min(1.0, ttl))
        glColor3f(c[0]*k + 0.25*(1-k), c[1]*k + 0.25*(1-k), c[2]*k + 0.25*(1-k))
        glVertex3f(x, y, z)
    glEnd()

# ---------------- Bullets (3D) ----------------
bullets = []
BULLET_SPEED = 2.0
BULLET_SIZE  = 0.04
BULLET_TTL   = 2.0
def fire_bullet_dir(dx, dy, dz):
    L = math.sqrt(dx*dx + dy*dy + dz*dz) or 1.0
    ux, uy, uz = dx/L, dy/L, dz/L
    hx, hy, hz = ship_half_extents_world()
    x0 = ship["p"][0] + ux * (hy + 0.04)
    y0 = ship["p"][1] + uy * (hy + 0.04)
    z0 = ship["p"][2] + uz * (hz + 0.04)
    bullets.append({"x": x0, "y": y0, "z": z0,
                    "vx": ux*BULLET_SPEED, "vy": uy*BULLET_SPEED, "vz": uz*BULLET_SPEED,
                    "s": BULLET_SIZE, "ttl": BULLET_TTL, "ph": random.uniform(0, 2*math.pi)})
def fire_bullet_up(): fire_bullet_dir(0.0, 1.0, 0.0)
def update_bullets(dt):
    for b in bullets:
        b["x"] += b["vx"] * dt; b["y"] += b["vy"] * dt; b["z"] += b["vz"] * dt; b["ttl"] -= dt
    bullets[:] = [b for b in bullets if b["ttl"] > 0]
def bullet_scale(b): return pulse_scale(t_global, b["ph"], BUL_PULSE_AMP, BUL_PULSE_FREQ)
def draw_bullets():
    if not bullets: return
    glColor3f(*BULLET_COLOR)
    for b in bullets:
        s = b["s"] * bullet_scale(b); x=b["x"]; y=b["y"]; z=b["z"]
        glPushMatrix(); glTranslatef(x,y,z)
        draw_cuboid_solid(s, s, s, BULLET_COLOR)
        glPopMatrix()
def bullet_aabb3d(b):
    s = b["s"] * bullet_scale(b)
    return {"x": b["x"]-s*0.5, "y": b["y"]-s*0.5, "z": b["z"]-s*0.5, "w": s, "h": s, "d": s}
def asteroid_aabb3d(a):
    r = a["r"] * asteroid_scale(a)
    return {"x": a["p"][0]-r, "y": a["p"][1]-r, "z": a["p"][2]-r, "w": 2*r, "h": 2*r, "d": 2*r}
def has_collided_AABB3D(b1, b2):
    return (
        b1["x"] < b2["x"] + b2["w"] and b1["x"] + b1["w"] > b2["x"] and
        b1["y"] < b2["y"] + b2["h"] and b1["y"] + b1["h"] > b2["y"] and
        b1["z"] < b2["z"] + b2["d"] and b1["z"] + b1["d"] > b2["z"]
    )

# ---------------- Bitmap Text (gluOrtho2D) ----------------
def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1, 1, 1)
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity()
    gluOrtho2D(0, winW, 0, winH)
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text: glutBitmapCharacter(font, ord(ch))
    glPopMatrix(); glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW)

def draw_text_colored(x, y, text, color, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(*color)
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity()
    gluOrtho2D(0, winW, 0, winH)
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text: glutBitmapCharacter(font, ord(ch))
    glPopMatrix(); glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW)

# ---------------- Menu & Instructions ----------------
def draw_menu_screen():
    draw_text(winW//2 - 180, int(winH*0.78), "WELCOME TO ASTEROID 3D")
    base_y = int(winH*0.60); offs = 34
    for i, name in enumerate(["EASY","MEDIUM","HARD"]):
        marker = ">" if i == difficulty_idx else " "
        draw_text(winW//2 - 120, base_y - i*offs, f"{marker}  MODE: {name}")
    draw_text(winW//2 - 220, int(winH*0.35), "Press E/M/H to choose mode")
    draw_text(winW//2 - 200, int(winH*0.30), "ENTER to continue")

def draw_instructions_screen():
    y = int(winH*0.76); draw_text(winW//2 - 120, y, "HOW TO PLAY"); y -= 40
    draw_text(120, y,   "- A/D/L/K : move Up/Down/Left/Right"); y -= 26
    draw_text(120, y,   "- W/S     : move Forward/Backward"); y -= 26
    draw_text(120, y,   "- '-'/'=' : speed -2 / +2"); y -= 26
    draw_text(120, y,   "- SPACE   : fire bullet"); y -= 26
    draw_text(120, y,   "- C       : cheat (auto-aim/auto-fire)"); y -= 26
    draw_text(120, y,   "- Camera  : arrows, RMB follow"); y -= 40
    draw_text(winW//2 - 220, y, "Press ENTER to START")

# ---------------- STASIS FEATURE (unchanged logic, now 3D) ----------------
stasis_crystals = []
stasis_spawn_timer = 0.0
STASIS_SPAWN_EVERY = 18.0
stasis_active = False
STASIS_DURATION = 8.0
stasis_time_left = 0.0
stasis_orbs = []
STASIS_ORB_COUNT = 8
def crystal_scale(c): return pulse_scale(t_global, c["ph"], CRY_PULSE_AMP, CRY_PULSE_FREQ)
def orb_scale(o):     return pulse_scale(t_global, o["ph"],  ORB_PULSE_AMP,  ORB_PULSE_FREQ)
def draw_diamond(r, col_light, col_dark):
    glBegin(GL_TRIANGLES)
    glColor3f(*col_light)
    glVertex3f(0,  r, 0); glVertex3f( r,0,0); glVertex3f(0,0, r)
    glVertex3f(0,  r, 0); glVertex3f(0,0, r); glVertex3f(-r,0,0)
    glVertex3f(0,  r, 0); glVertex3f(-r,0,0); glVertex3f(0,0,-r)
    glVertex3f(0,  r, 0); glVertex3f(0,0,-r); glVertex3f( r,0,0)
    glColor3f(*col_dark)
    glVertex3f(0, -r, 0); glVertex3f(0,0, r); glVertex3f( r,0,0)
    glVertex3f(0, -r, 0); glVertex3f(-r,0,0); glVertex3f(0,0, r)
    glVertex3f(0, -r, 0); glVertex3f(0,0,-r); glVertex3f(-r,0,0)
    glVertex3f(0, -r, 0); glVertex3f( r,0,0); glVertex3f(0,0,-r)
    glEnd()
def spawn_stasis_crystal():
    r = random.uniform(0.07, 0.10)
    y = Y_MAX + r + 0.08
    x = random.uniform(-X_MAX + r, X_MAX - r)
    z = random.uniform(Z_MIN + r, Z_MAX - r)
    vy = -random.uniform(0.14, 0.22)
    stasis_crystals.append({"p":[x,y,z], "r":r, "vy":vy, "ph":random.uniform(0, 2*math.pi)})
def update_stasis_crystals(dt):
    global stasis_spawn_timer
    stasis_spawn_timer += dt
    if stasis_spawn_timer >= STASIS_SPAWN_EVERY:
        spawn_stasis_crystal(); stasis_spawn_timer = 0.0
    for c in stasis_crystals: c["p"][1] += c["vy"] * dt
    stasis_crystals[:] = [c for c in stasis_crystals if c["p"][1] > Y_MIN - c["r"] - 0.20]
def draw_stasis_crystal(c):
    x,y,z=c["p"]; r=c["r"]; sc = crystal_scale(c)
    glPushMatrix(); glTranslatef(x,y,z); glScalef(sc, sc, sc)
    draw_diamond(r, (0.35,0.90,1.0), (0.15,0.55,0.85))
    glPopMatrix()
def collided_ship_crystal(c):
    sx, sy, sz = ship["p"]; cx, cy, cz = c["p"]
    R = ship_collision_radius() + c["r"] * crystal_scale(c)
    dx = cx - sx; dy = cy - sy; dz = cz - sz
    return (dx*dx + dy*dy + dz*dz) <= (R*R)
def activate_stasis():
    global stasis_active, stasis_time_left, bullets, blasts
    stasis_active = True
    stasis_time_left = STASIS_DURATION
    bullets = []; blasts  = []
    spawn_stasis_orbs()
def spawn_stasis_orbs():
    global stasis_orbs
    stasis_orbs = []
    for _ in range(STASIS_ORB_COUNT):
        y = random.uniform(Y_MIN + 0.15, Y_MAX - 0.10)
        x = random.uniform(-X_MAX + 0.05, X_MAX - 0.05)
        z = random.uniform(Z_MIN + 0.05, Z_MAX - 0.05)
        stasis_orbs.append({"p":[x,y,z], "r":0.06, "ph": random.uniform(0, 2*math.pi)})
def draw_stasis_orb(o):
    x,y,z=o["p"]; r=o["r"]; sc = orb_scale(o)
    glPushMatrix(); glTranslatef(x,y,z); glScalef(sc, sc, sc)
    draw_sphere_solid(r*1.06, 14, 10, OUTLINE_BLACK, OUTLINE_BLACK)
    draw_sphere_solid(r, 18, 12, (0.15,0.95,0.55), (0.10,0.60,0.40))
    glPopMatrix()
def collided_ship_stasis_orb(o):
    sx, sy, sz = ship["p"]; ox, oy, oz = o["p"]
    R = ship_collision_radius() + o["r"] * orb_scale(o)
    dx = ox - sx; dy = oy - sy; dz = oz - sz
    return (dx*dx + dy*dy + dz*dz) <= (R*R)

# ---------------- Window-edge boundary overlay ----------------
def _draw_screen_rect(x0, y0, x1, y1, col):
    glColor3f(*col)
    glBegin(GL_QUADS)
    glVertex2f(x0, y0); glVertex2f(x1, y0); glVertex2f(x1, y1); glVertex2f(x0, y1)
    glEnd()

def draw_boundary_starfield():
    """
    Draw a clean frame on the four edges of the window in screen space.
    This is an overlay (ignores depth) so it's always visible.
    """
    # Thickness in pixels, scaled by window size but clamped.
    thick = max(6, int(0.014 * min(winW, winH)))
    accent = max(3, int(thick * 0.45))

    # Save state and switch to 2D overlay
    glPushAttrib(GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT)
    glDisable(GL_DEPTH_TEST)

    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity()
    gluOrtho2D(0, winW, 0, winH)
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()

    # Outer dark rails
    _draw_screen_rect(0, 0, winW, thick, RING_DARK)              # bottom
    _draw_screen_rect(0, winH - thick, winW, winH, RING_DARK)    # top
    _draw_screen_rect(0, 0, thick, winH, RING_DARK)              # left
    _draw_screen_rect(winW - thick, 0, winW, winH, RING_DARK)    # right

    # Inner bright accents
    glow = (0.20, 0.85, 1.00)
    _draw_screen_rect(thick, 0, thick + accent, winH, glow)                  # left inner
    _draw_screen_rect(winW - thick - accent, 0, winW - thick, winH, glow)    # right inner
    _draw_screen_rect(0, thick, winW, thick + accent, glow)                  # bottom inner
    _draw_screen_rect(0, winH - thick - accent, winW, winH - thick, glow)    # top inner

    # Restore matrices/state
    glPopMatrix(); glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW)
    glPopAttrib()

# ---------------- Update & Display ----------------
def update():
    global prev_time, lives, score, game_over, t_global
    global gun_angle_deg, autofire_timer, slow_timer, alert_timer
    global bh_next_spawn, stasis_time_left, stasis_active
    now = time.time(); dt = now - prev_time; prev_time = now

    if game_state != STATE_PLAY:
        glutPostRedisplay(); return

    t_global = now_t()

    if game_over or paused:
        glutPostRedisplay(); return

    update_camera_from_state()

    if stasis_active:
        update_bonus_texts(dt)
        for o in list(stasis_orbs):
            if collided_ship_stasis_orb(o):
                score += 3
                spawn_bonus_text(o["p"][0], o["p"][1], o["p"][2])
                stasis_orbs.remove(o)
        stasis_time_left = max(0.0, stasis_time_left - dt)
        if stasis_time_left <= 0.0:
            stasis_orbs.clear()
            stasis_active = False
        glutPostRedisplay()
        return

    if slow_timer  > 0.0: slow_timer  = max(0.0, slow_timer - dt)
    if alert_timer > 0.0: alert_timer = max(0.0, alert_timer - dt)

    if cheat_active:
        gun_angle_deg = (gun_angle_deg + GUN_SPIN_SPEED_DEG * dt) % 360.0
        autofire_timer -= dt
        a = math.radians(gun_angle_deg); fx, fy = math.sin(a), math.cos(a)
        fz = 0.0
        should_fire = False
        for astd in asteroids:
            dx = astd["p"][0] - ship["p"][0]
            dy = astd["p"][1] - ship["p"][1]
            dz = astd["p"][2] - ship["p"][2]
            L = math.sqrt(dx*dx + dy*dy + dz*dz)
            if L <= 1e-6: continue
            dot = (dx*fx + dy*fy + dz*fz) / L
            if dot > AIM_COS_THRESH and dot > 0.0: should_fire = True; break
        if should_fire and autofire_timer <= 0.0:
            fire_bullet_dir(fx, fy, fz); autofire_timer = AUTOFIRE_COOLDOWN

    update_asteroids(dt)
    update_bonuses(dt)
    update_blasts(dt)
    update_bullets(dt)
    update_bonus_texts(dt)
    update_stasis_crystals(dt)

    target = blackhole_target_count()
    if target > 0:
        bh_next_spawn -= dt
        if len(blackholes) < target and bh_next_spawn <= 0.0:
            spawn_one_blackhole(); bh_next_spawn = BH_RESPAWN_AFTER
        update_blackholes_motion(dt)

        i = 0
        while i < len(blackholes):
            bh = blackholes[i]
            if collided_ship_blackhole(bh):
                score = max(0, score - 2)
                slow_timer = 5.0
                alert_timer = 1.6
                if difficulty_idx == 2 and not game_over:
                    lives = max(0, lives - 2)
                    if lives <= 0: game_over = True
                despawn_blackhole_at(i); bh_next_spawn = BH_RESPAWN_AFTER
            else:
                i += 1

    if not cheat_active:
        for a in list(asteroids):
            if collided_ship_asteroid(a):
                if lives > 0: lives -= 1
                spawn_blast(a["p"][0], a["p"][1], a["p"][2], count=120)
                asteroids.remove(a)
                if lives <= 0: game_over = True; break

    if game_over:
        glutPostRedisplay(); return

    for b in list(bullets):
        Bb = bullet_aabb3d(b); hit_idx = -1
        for i, a in enumerate(asteroids):
            if has_collided_AABB3D(Bb, asteroid_aabb3d(a)): hit_idx = i; break
        if hit_idx >= 0:
            a = asteroids[hit_idx]; ax, ay, az = a["p"]
            if difficulty_idx == 2 and a.get("split", False) and a["r"] > SPLIT_MIN_R:
                r_child = max(SPLIT_MIN_R * 0.75, a["r"] * 0.5); dx_off = r_child * 0.6
                asteroids.pop(hit_idx)
                asteroids.append({"p":[ax - dx_off, ay, az], "r":r_child, "vy":a["vy"]*1.05,
                                  "vz":-abs(a["vz"]), "type":"normal","split":False,"ph": random.uniform(0, 2*math.pi)})
                asteroids.append({"p":[ax + dx_off, ay, az], "r":r_child, "vy":a["vy"]*1.05,
                                  "vz": abs(a["vz"]), "type":"normal","split":False,"ph": random.uniform(0, 2*math.pi)})
                spawn_blast(ax, ay, az, count=90)
            else:
                score += 1; spawn_blast(ax, ay, az, count=100); asteroids.pop(hit_idx)
            bullets.remove(b)

    for bo in list(bonuses):
        if collided_ship_bonus(bo):
            score += 3; spawn_bonus_text(bo["p"][0], bo["p"][1], bo["p"][2])
            spawn_blast(bo["p"][0], bo["p"][1], bo["p"][2], count=60)
            bonuses.remove(bo)

    for c in list(stasis_crystals):
        if collided_ship_crystal(c):
            stasis_crystals.remove(c)
            activate_stasis()
            break

    glutPostRedisplay()

def display():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    if game_state == STATE_PLAY and (not paused) and (not game_over):
        update_camera_from_state()

    glMatrixMode(GL_PROJECTION); glLoadIdentity()
    aspect = max(1e-6, winW/float(winH))
    gluPerspective(FOVY_DEG, aspect, NEAR_PLANE, FAR_PLANE)

    glMatrixMode(GL_MODELVIEW); glLoadIdentity()
    gluLookAt(EYE_CUR[0],EYE_CUR[1],EYE_CUR[2],
              CTR_CUR[0],CTR_CUR[1],CTR_CUR[2],
              UP[0],UP[1],UP[2])

    # Background + stars
    draw_sky_fullscreen()
    draw_stars(t_global)

    # 3D world
    if game_state == STATE_MENU:
        draw_menu_screen()
    elif game_state == STATE_INSTR:
        draw_instructions_screen()
    else:
        for a in asteroids: draw_asteroid(a)
        for b in bonuses:  draw_bonus(b)
        for c in stasis_crystals: draw_stasis_crystal(c)
        if blackhole_target_count() > 0: draw_blackholes()
        for o in stasis_orbs: draw_stasis_orb(o)
        draw_spaceship()
        draw_bullets()
        draw_blasts()

        # HUD
        draw_text(16,  winH - 30, f"LIVES: {lives}")
        draw_text(160, winH - 30, f"SCORE: {score}")
        draw_text(360, winH - 30, f"STEP: {current_step():.2f} (SPEED {speed_units})")
        if cheat_active: draw_text(600, winH - 30, "CHEAT: ON")
        if slow_timer > 0.0: draw_text(16, winH - 55, f"SLOWED: {slow_timer:0.1f}s")
        if alert_timer > 0.0:
            draw_text_colored(winW//2 - 150, winH - 70, "!!! RED ALERT: BLACKHOLE HIT !!!", (1.0, 0.1, 0.1))
        if stasis_active:
            draw_text_colored(winW//2 - 110, winH - 100, f"STASIS {stasis_time_left:0.1f}s", (0.2, 1.0, 0.6))
        if game_over:
            draw_text(winW//2 - 80, winH//2, "GAME OVER")
            draw_text(winW//2 - 160, winH//2 - 30, "Press R to return to MENU")
        if paused:
            draw_text_colored(winW//2 - 60, winH//2 + 30, "PAUSED", (1.0, 0.95, 0.2))
            draw_text(winW//2 - 120, winH//2, "Press P to resume")

        draw_bonus_texts_overlay()

    # Draw the window-edge boundary LAST so it stays on top
    draw_boundary_starfield()

    glutSwapBuffers()

# ---------------- Keyboard / Mouse ----------------
def keyboard(key, x, y):
    global game_over, game_state, difficulty_idx, cheat_active, gun_angle_deg, autofire_timer, speed_units, paused
    if key == b'\x1b': sys.exit()
    if key in (b'\r', b'\n'):
        if game_state == STATE_MENU:  game_state = STATE_INSTR
        elif game_state == STATE_INSTR: start_game()
        return
    if game_state == STATE_MENU:
        lk = key.lower()
        if lk == b'1' or lk == b'e': difficulty_idx = 0
        elif lk == b'2' or lk == b'm': difficulty_idx = 1
        elif lk == b'3' or lk == b'h': difficulty_idx = 2
        glutPostRedisplay(); return
    if key.lower() == b'r':
        to_menu(); return
    if game_state != STATE_PLAY: return
    if key.lower() == b'p':
        paused = not paused; glutPostRedisplay(); return
    if paused: return
    lk = key.lower()
    if lk == b'c':
        cheat_active = not cheat_active
        gun_angle_deg = gun_angle_deg % 360.0; autofire_timer = 0.0
        return
    if key == b'-': speed_units = max(SPEED_UNIT_MIN, speed_units - 2); return
    if key == b'=': speed_units += 2; return
    if game_over: return
    step = current_step()
    # XY
    if lk == b'a': ship["p"][1] += step
    if lk == b'd': ship["p"][1] -= step
    if lk == b'l': ship["p"][0] -= step
    if lk == b'k': ship["p"][0] += step
    # Z (true 3D)
    if lk == b'w': ship["p"][2] += step    # toward camera
    if lk == b's': ship["p"][2] -= step    # away
    if key == b' ':
        if not stasis_active: fire_bullet_up()
    clamp_ship_inside()

def special_keys(key, x, y):
    global cam_yaw_deg, cam_height
    if game_state != STATE_PLAY: return
    if paused or game_over: return
    if key == GLUT_KEY_LEFT and not cam_follow:  cam_yaw_deg = (cam_yaw_deg - 5.0) % 360.0
    if key == GLUT_KEY_RIGHT and not cam_follow: cam_yaw_deg = (cam_yaw_deg + 5.0) % 360.0
    if key == GLUT_KEY_UP:    cam_height = min(3.0, cam_height + 0.10)
    if key == GLUT_KEY_DOWN:  cam_height = max(0.35, cam_height - 0.10)
    glutPostRedisplay()

def mouse(btn, state, x, y):
    global cam_follow
    if game_state != STATE_PLAY: return
    if paused or game_over: return
    if btn == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:
        cam_follow = not cam_follow
        glutPostRedisplay()

# ---------------- Start/Restart helpers ----------------
def start_game():
    global lives, score, game_over, asteroids, blasts, bullets, bonuses, bonus_texts
    global start_time, prev_time, t_global, game_state
    global cheat_active, gun_angle_deg, autofire_timer, speed_units, paused
    global blackholes, bh_next_spawn, slow_timer, alert_timer
    global stasis_crystals, stasis_spawn_timer, stasis_active, stasis_time_left, stasis_orbs
    global cam_follow, cam_yaw_deg, cam_radius, cam_height
    apply_difficulty()
    lives = MAX_LIVES; score = 0; game_over = False
    cheat_active = False; gun_angle_deg = 0.0; autofire_timer = 0.0
    speed_units = 6; slow_timer = 0.0; alert_timer = 0.0
    paused = False
    asteroids = []; blasts = []; bullets = []; bonuses = []; bonus_texts = []
    blackholes = []; bh_next_spawn = BH_RESPAWN_AFTER
    stasis_crystals = []; stasis_spawn_timer = 0.0
    stasis_active = False; stasis_time_left = 0.0; stasis_orbs = []
    reset_next_bonus()
    ship["p"] = [0.0, -0.25, 0.0]; ship["ph"] = random.uniform(0, 2*math.pi)
    for _ in range(6): spawn_asteroid()
    start_time = time.time(); prev_time  = start_time; t_global   = now_t()
    cam_follow = False; cam_yaw_deg = 0.0; cam_radius = 2.2; cam_height = 1.6
    update_camera_from_state()
    clamp_ship_inside(); game_state = STATE_PLAY

def to_menu():
    global game_state, start_time, prev_time, t_global, paused
    start_time = time.time(); prev_time  = start_time; t_global   = now_t()
    paused = False
    game_state = STATE_MENU

# ---------------- Init & Main ----------------
def main():
    glutInit(sys.argv)
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(winW, winH)
    glutCreateWindow(b"Asteroid 3D - True 3D Gameplay")
    glViewport(0, 0, winW, winH)  # hardcoded

    glutDisplayFunc(display)
    glutIdleFunc(update)
    glutKeyboardFunc(keyboard)
    glutSpecialFunc(special_keys)
    glutMouseFunc(mouse)

    init_stars()
    global start_time, prev_time, t_global
    start_time = time.time(); prev_time  = start_time; t_global   = now_t()
    update_camera_from_state()
    clamp_ship_inside()
    glutMainLoop()

if __name__ == "__main__":
    main()